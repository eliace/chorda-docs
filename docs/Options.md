## Опции компонента

### Виды опций
Опции делятся на:
1. Конфигурационные (`mixins`, `options`)
2. Структурные (`items`, `components`, `defaultItem`, `key`, `as` и др.)
3. Отрисовщика (`layout`, `dom`, `renderers` и др.)
4. Контекстные (`scope`, `joints` и др.)
5. Вспомогательные (`text`, `classes`, `styles`, `width`, `css` и др.)

#### Конфигурация
С помощью этих опций настраивается или изменяется конфигурация компонента. Базовыми являются: `options` и `mixins`

#### Структура
Эти опции позволяют декларативно управлять структурой. Базовыми являются две опции: `items` и `components`. Все остальные можно назвать производными от базовых.

Также поддерживаются динамические опции шаблонирования, они начинаются с `$`, например `$header`

#### Отрисовка
Базовые свойства отрисовщика: `renderer`, `layout` и `dom`. Они отвечают за подключение отрисовщика, компоновку и эффекты. Остальные свойства являются производными от них.

#### Контекст
Базовые свойства контекста: `scope` и `joints`.

Контекст работает с динамическими опциями, котоые заканчиваются на `Changed`, например `dataChanged`


### Использование опций
При создании компонента опции передаются как один из входящих параметров
```javascript
const html = new Html({
    text : 'Привет!!!',
    css : 'hello-text'
})
```

Динамически опции изменяются с помощью метода `opt()`
```javascript
const html = new Html({
    text: 'Текст по умолчанию',
    onClick: function () {
        this.opt('text', 'Активирован')
    }
})
```

## Экспонирование опций



## Слияние опций

Для каждой опции можно определить свое правило слияния.


### Примешивание опций

Часть опций можно не определять каждый раз для каждого компонента, а задать в качестве примеси и использовать только по необходимости.

```javascript
function withRedBackground (mixer) {
    mixer.mix({
        css: 'background-red'
    })
}

new Html({
    css: 'text-white',
    mixins: { withRedBackground }
})
```
Отличие примесей от опций в том, что вторые могут принимать значение и, в зависимости от него, менять логику примешивания

Примеси имеют и более компактную форму определения через `return`
```javascript
function withLabel () {
    return {
        $label: {
            html: 'label'
        }
    }
}
```

Поскольку класс содержит в себе конфигурацию, то его тоже можно использовать как примесь

### Примеси и наследование

Если класс содержит только конфигурацию, то зачем ситема классов вообще нужна? Ведь можно использовать примеси, получая нужную композицию в нужном месте?

Классы позволяют решить несколько проблем:
* Порядок применения примесей не определен. В классе конфигурации смешиваются в порядке наследования
* Примешивание происходит каждый раз, когда создается компонент. Класс выполняет смешивание только один раз, после чего кэширует полученную конфигурацию
* Определение элементов в разнородных коллекциях может оказаться достаточно многословным. Классы позволяют упростить написание фабрик элементов.


## Конфигурирование компонента

#### Класс
```javascript
class MyComponent extends Html {
    options () {
        return {
            labelText: {
                mix: function (v, mixer) {
                    mixer.mix({
                        $label: {
                            text: v
                        }
                    })
                }
            },
            icon: {
                set: function (next, prev) {
                    this.classes = {['icon-'+prev]: false, ['icon-'+next]: true}
                }
            }
        }
    }
}
```
#### Экземпляр

```javascript
new Html({
    color: 'red',
    options: {
        color: {
            set: function (v) {
                this.styles = {backgroundColor: v}
            }
        }
    }
})
```

Все опции имеют альтернативную форму определения с использованием `return`
```javascript
...
color: {
    set: function (v) {
        return {styles: {borderColor: v}}
    }
}
...
```
