## Область видимости и контекст

#### Область видимости (скоуп)

Область видимости (скоуп) объекта формируется из контекста. В свою очередь контекст дочерних объектов формируется из области видимости родительского. Таким образом получается каскадируемый контекст, похожий по своему поведению на прототипное наследование javascript.

```javascript
new Html({
    scope: {
        // добавляя переменную в скоуп мы делаем ее доступной всем дочерним элементам на всех уровнях
        title: 'Coffee'
    },
    $header: {
        $title: {
            $link: {
                // здесь значение переменной title можно получить через скоуп
            }
        }
    }
});
```
Каждый компонент имеет свой объект `scope`. Скоупы компонентов `$header` и `$link` не равны друг другу, но содержат те же переменные. Это означает, что доабвление новых переменных в скоупах потомков не влияет на родительский скоуп.

#### Иерархия областей видимости
```javascript
new Html({
    // вэтом скоупе только description
    scope: {
        description: 'Hello'
    },
    $image: {
        // этот скоуп содержит и image, и description
        scope: {
            image: 'mountains.jpg'
        }
    }
});
```

#### Область видимости класса
Как только мы выносим некоторый функционал в отдельный класс, вместе с ним можно вынести и определения области видимости. Нюанс только в том, что данные на уровне класса не известны. Мы можем, к примеру, выставить значения по умолчанию.

```javascript
class Image extends Html {
    config () {
        return {
            // описываем скоуп пустыми значениями
            scope: {
                image: ''
                description: ''
            },
            html: 'img',
            src: $value('image'),
            alt: $value('description'),
        }
    }
}

new Html({
    $image: {
        as: Image,
        // перекрываем скоуп компонента image своими значениями
        scope: {
            description: 'Hello',
            image: 'mountains.jpg'
        }
    }
});
```

## Реактивность
Для того, чтобы возникала реакция, компонент должен подписаться на изменения переменной (связывание). Это происходит в случаях, когда среди опций есть:
* реактивные функции (`changed`)
* реактивные значения (`$value`, `$all`)
* функции подключения (`joints`)

#### Реактивная функция
```javascript
new Html({
    scope: {
        data: 100,
        title: 'Hello'
    },
    $content: {
        dataChanged: function (v) {
            // v == 100
            // здесь мы можем изменить свойства компонента
        }
    },
    $description: {
        titleChanged: function (v) {
            // v == 'Hello'
            // изменим свойство text
            this.opt('text', v)
        }
    }
});
```

#### Реактивное значение
```javascript
new Html({
    scope: {
        pic: 'sunflower.jpg',
        title: 'Hello'
    },
    $header: {
        text: $value('title') // связываем опцию text со значением переменной скоупа title
    },
    $image: {
        src: $value('pic')
    }
});
```


## Коллекции
Коллекции в javascript представлены типами `Object` и `Array`. В первую очередь компонентам коллекции нужны для управления структурой, т.е. для свойств `components` и `items`. Рассмотрим, как они работают со связанными данными

#### Итератор
Мы можем связать структурные свойства, как и простые - через `$value`
```javascript
new Html({
    scope: {
        list: ['Coffee', 'Tea', 'Milk'],
        map: {
            header: true,
            content: true,
            footer: false
        }
    },
    $header: {
        // в контексте есть переменная map = {header: true, content: true, footer: false}
    },
    $content: {
        defaultItem: {
            // через контекст нам доступна переменная list = ['Coffee', 'Tea', 'Milk']
        },
        items: $value('list')
    },
    $footer: {},
    components: $value('map')
});
```
Структура создается, соответсвенно связанным данным, но дочерние элементы не имеют собственного контекста - их скоупы идентичны скоупу родителя.

Для создания дочернего скоупа мы можем воспользоваться итератором `$all`
```javascript
new Html({
    scope: {
        list: ['Coffee', 'Tea', 'Milk']
    },
    $content: {
        defaultItem: {
            // теперь в скоупе есть переменная item, равная для каждого из элементов 'Coffee', 'Tea' или 'Milk'
        },
        items: $all('list', 'item')
    }
});
```
<div class="alert is-info">
Поведение components аналогично поведению items
</div>



## Совместное использование данных
Рассмотрим пример, где в двух разных ветках дерева компонентов находятся тесктовое поле и поле ввода
```javascript
new Html({
    scope: {
        num: 0
    },
    $form: {
        $input: {
            html: 'input',
            numChanged: function (v) {
                this.opt('value', v)
            },
            onChange: function (e, $scope) {
                $scope.num.$set(e.target.value)  // в скоупе на самом деле находится реактивная обертка над num
            }
        },
        $result: {
            numChanged: function (v) {
                this.opt('text', v)
            }
        }
    }
});
```
При изменении данных в поле ввода, меняются данные и в текстовом поле. Это реализуется за счет реактивных оберток над данными, которые создаются в скоупе.
<div class="alert is-info">
Сами данные не меняются, не копируются, а остаются как есть. Это значит, что компоненты могут совместно использовать практически любые объекты, даже другие компоненты или их конфигурации.
</div>

```javascript
new Html({
    scope: {
        columns: [{
            text: 'num',
            width: '20%'            
        }, {
            text: 'title',
            width: '80%'
        }]
    },
    $table: {
        html: 'table',
        $header: {
            html: 'thead',
            $columns: {
                html: 'tr',
                columnsChanged: function (v) {
                    this.opt('items', v) // значение колонок используется как набор опций дочерних элементов
                }
            }
        }
    }
});
```
