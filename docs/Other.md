## Каналы
Можно сказать, что это сложная тема, поскольку речь не пойдет о технологии, а о несколько иной точке зрения на проблему.

Элементы структуры являются самодостаточными, они могут управлять прямыми потомками, знают родителе и имеют контекст, определяющий их текущее состояние. Все понятно с корневым элементом и элементами-листьями: корневой элемент содержит в себе общее состояние, а листья - примитивные состояния, являющиеся частью общего. Отсюда легко определить их задачи:
* root - максимально полное описание модели данных структуры
* leaf - отображение примитивных данных на свойства отрисовки

А что с элементами посередине, ветвями? Внезапно, если их не игнорировать, оказывается, что функций здесь заметно больше:

1. доставить даные от корня к листьям, причем эти данные для ветвей могут даже не нести смысла на уровне ветви
2. добнасытить контекст локальными данными
3. ветвями может потребляться часть данных, как правило тех, которые влияют на низлежащую структуру

Из сказанного выше следует, что скоуп промежуточного элемента может быть наполнен неизвестными и неконтролируемыми данными.

Есть еще одна неочевидная проблема, связанная с реактивными обертками. Скоупы являются независимыми друг от друга, а значит должны иметь свои собственные обертки, которые реагируют на изменения. Но в таком случае родительские скоупы никогда не узнают об изменениях в дочерних. Для того, чтобы данные корректно распространялись, скоупы используют одни и те же обертки, как бы пронизывая структуру сверху вниз, формируя таким образом канал передачи данных. С точки зрения скоупов переменные это именованные каналы распространения данных.
<div class="alert is-info">
Особенность реализации реактивной обертки в том, что она не содержит самих данных, а только путь к ним в структуре данных.
</div>




```javascript
new Html({
    scope: {
        // title и color выставляются один раз при создании компонента, значит их можно объединить в один канал data
        data: {
            title: 'Coffee',
            color: 'red'
        }
    },
    $header: {
        $title: {
            dataChanged: function (v) {
                this.opt('text', v.text)
                this.opt('styles', {color: v.color})
            }
        }
    }
});
```


## Делегирование модели

Задавая скоуп в каждом отдельном компоненте мы быстро превратим наш код в спагетти. Гораздо удобнее управлять всем из одного корневого скоупа, которому потомки "делегируют" свои переменные (если мы смотрим на проблему со стороны компонентов-потомков). Но для этого скоуп класса должен понимать, что данные нужно откуда-то взять. Откуда? Конечно из контекста, который по сути является скоупом родителя.
```javascript
class Image extends Html {
    config () {
        return {
            scope: {
                image: (ctx) => ctx.image || '' // переменная скоупа может быть задана как функция инициализации
            }
        }
    }
}
new Html({
    scope: {
        image: 'sunflower.jpg'
    },
    $content: {
        $image: {
            as: Image
        }
    }
});
```

Итак, мы создали отдельный класс, в котором есть переменная скоупа `image` и через которую задается url картинки. А что, если таких картинок несколько и в корневом скоупе они, естественно, называются по-разному?
```javascript
new Html({
    scope: {
        image1: 'sunflower.jpg',
        image2: 'mountains.jpg'
    },
    $header: {
        // здесь мы можем ввести в скоуп переменную image, которая будет использована дочерним Image
        scope: {
            image: (ctx) => ctx.image1
        },
        $image: {
            as: Image
        }
    },
    $footer: {
        scope: {
            image: (ctx) => ctx.image2
        },
        $image: {
            as: Image
        }
    }
});
```

## Глобальные примеси

